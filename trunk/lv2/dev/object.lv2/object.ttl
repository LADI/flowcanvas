# LV2 Objects Extension
#
# Copyright (C) 2007 Dave Robillard
# 
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.

@prefix obj:  <http://lv2plug.in/ns/dev/objects#> .
@prefix lv2:  <http://lv2plug.in/ns/lv2core#> .
@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd:  <http://www.w3.org/2001/XMLSchema> .
@prefix doap: <http://usefulinc.com/ns/doap#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .

<http://lv2plug.in/ns/dev/objects>
	a lv2:Specification ;
    doap:name "LV2 Objects" ;
	rdfs:comment """
This extension defines a genic format for "objects" (e.g. integers,
strings, buffers, data structures, etc) to be used by LV2 plugins and hosts.
Objects may be contained directly in port buffers, or used in other ways,
e.g. as the payload of an event or as persistent data.  Objects are very
simple chunks of memory with a type and a size, and are (with one exception)
POD and may be safely copied (allowing plugins and hosts to communicate
objects of any type, even if they do not understand them).

Optionally, the host may support "Blobs", which are dynamically allocated
chunks of memory that (unlike "Objects") are not necessarily POD.  Blobs
are referred to by references, which are a special case of Object that
always have type 0, are not POD, and can only be copied using host provided
functions.  Blob support requires the host to support the
<a href="http://lv2plug.in/ns/ext/uri-map">LV2 URI Map</a> extension.
""" .


obj:ObjectPort a rdfs:Class ;
    rdfs:label      "Object Port" ;
    rdfs:subClassOf lv2:Port ;
    rdfs:comment    """
Ports of this type will be connected to a region of 32-bit aligned memory
that starts with a uint32_t type, immediately followed by a uint32_t size,
immediately followed by that many bytes of data (see LV2_Object in object.h).

This is an abstract port type.  A port that is a obj:ObjectPort MUST also
have a more descriptive type that is a subClassOf obj:ObjectPort which
defines the port's semantics (probably obj:ValuePort or obj:MessagePort).

Before calling a method on the plugin that writes to an ObjectPort output,
the host MUST set the size of the Object in that output to the amount of
available memory immediately following the Object header.  The plugin MUST
write a valid Object that port (leaving it untouched is illegal).  If there
is no reasonable value to write to the port, the plugin MUST write null
(the object with both type and size equal to zero).
""" .


obj:asLargeAs a rdf:Property ;
    rdfs:domain  obj:ObjectPort ;
    rdfs:range   obj:ObjectPort ;
    rdfs:label   "as large as" ;
    rdfs:comment """
Indicates that an object port requires at least as much buffer space as
another.  If a port is asLargeAs several ports, it is asLargeAs the largest
such port (not the sum of those ports' sizes).

The host guarantees that whenever the run method (or equivalent) for an
ObjectPort is called, any output O that is obj:asLargeAs an input I is
connected to a buffer large enough to copy I, or NULL if the port is
lv2:connectionOptional.
""" .


obj:respondsWith a rdf:Property ;
    rdfs:domain  obj:MessagePort ;
    rdfs:range   obj:MessagePort ;
    rdfs:label   "responds with" ;
    rdfs:comment """
Indicates that an message port responds to messages via another port.
If <pre>input obj:respondsWith output</pre> then after running the plugin
with a message <em>m</em> in <code>input</code> the host SHOULD interpret
the object in <code>output</code> as the response to <em>m</em>.
""" .


obj:ValuePort a rdfs:Class ;
    rdfs:label      "Value Port" ;
    rdfs:subClassOf obj:ObjectPort ;
    rdfs:comment    """
The contents of a ValuePort are considered persistent and time-independent.
<ul>
<li>If a plugin has fixed input values for all ports, all ValuePort outputs
are also fixed regardless of the number of times the plugin is run.</li>
<li>If a plugin has fixed input values for all ports except a ValuePort,
each value V of that ValuePort corresponds to a single set of outputs
for all ports.</li>
<li>If an obj:ValuePort contains a reference then the blob it refers to is
constant; plugin MUST NOT modify the blob in any way.
</ul>

Intuitively, the contents of a ValuePort are values (which are computed),
NOT commands (which are executed, or otherwise consumed to manipulate state).
""" .


obj:MessagePort a rdfs:Class ;
    rdfs:label      "Message Port" ;
    rdfs:subClassOf obj:ObjectPort ;
    rdfs:comment    """
An ObjectPort that consumes or executes its value as a "message".
The contents of a MessagePort are considered transient and/or time-dependent,
and only apply for a single invocation of the run method (or equivalent).
Unlike a ValuePort, a MessagePort may be used to manipulate and access internal
plugin state.

Intuitively, the contents of a MessagePort are commands (which are executed
or consumed once).

Plugins may respond to messages via another messagePort as specified by
the obj:respondsWith property.
""" .


obj:ObjectType a rdfs:Class ;
	rdfs:label   "LV2 Object Type" ;
	rdfs:comment """
Base class for all types of LV2 Objects.

All Object types (instances of this class, which are themselves classes) must
define a precise binary layout for that type of object, which dictates the
format of the data following the LV2_Object header.  Pedantically, this class
refers to the type of memory starting where the LV2_Object header starts,
i.e. a chunk of memory with any type that is a subClassOf obj:ObjectType
by definition starts with an LV2_Object.  The area after the header is
referred to as the object's "body".

The URIs of subclasses of obj:ObjectType are mapped to integers and used as
the type field of an LV2_Object.  If a plugin or host does not understand
the type of an LV2_Object, that object SHOULD simply be ignored.

All objects are POD by definition, except references, which have type 0.
An object MUST NOT contain a reference.  It is safe to copy any type of
object except type 0 with a simple memcpy using the size field, even if the
implementation does not understand the actual type of that object.
""" .


obj:Reference a obj:ObjectType ;
	rdfs:label   "Reference" ;
	rdfs:comment """
Reference to a blob.  The actual contents of a reference are opaque and host
specific, and must not be copied, serialized, or otherwise interpreted by
a plugin.

References are a special case: a reference object always has type 0.
The NULL reference has size 0.
""" .


obj:String a obj:ObjectType ;
	rdfs:label "String" ;
	rdfs:comment """
A UTF-8 encoded string, where LV2_Object.size refers to the length of the
string in bytes (not characters).
""" .


obj:Tuple a obj:ObjectType ;
	rdfs:label "Tuple" ;
	rdfs:comment """
A POD heterogeneous sequence of Objects.  A Tuple can contain objects of
varying type and varying size.  The body of the tuple
is simply the body of the first element, followed by the body of the
second, etc., where each is aligned to 32-bits.
""" .

obj:Vector a obj:ObjectType ;
	rdfs:label "Vector" ;
	rdfs:comment """
A POD homogeneous sequence of objects with equivalent type and size.

The body of a vector begins with
<pre>
uint32_t elem_count; // The number of elements in the vector
uint32_t elem_type;  // The type of each element
</pre>
followed by <code>elem_count</code> bodies of objects of type
<code>elem_type</code>, each with equivalent size.  For variably sized
content types, this size can be calculated using the total byte size of the
vector, e.g.
<pre>
uint32_t elem_size = (vector.size - (2 * sizeof(uint32_t))) / vector.count);
</pre>
Note that it is possible to construct a valid Object for each element of the
vector, even by an implementation which does not understand <code>type</code>.

For example, an obj:Vector containing 42 elements of type obj:Int32 looks
like this in memory:
<pre>
uint32_t object_type  = uri_map(obj:Vector)
uint32_t object_size  = (2 * sizeof(uint32_t)) + (42 * sizeof(int32_t))
uint32_t elem_count   = 42
uint32_t elem_type    = uri_map(obj:Int32)
int32_t  contents[42] = ...
</pre>
""" .

obj:Int32   a obj:ObjectType ; rdfs:label "Signed 32-bit Integer" .
obj:Bool    a obj:ObjectType ; rdfs:label "Same as obj:Int32 (0 = false, 1 = true)" .
obj:Float32 a obj:ObjectType ; rdfs:label "32-bit Floating Point Number" .


obj:blobSupport a lv2:Feature ;
	rdfs:label "Blob support" ;
	rdfs:comment """
Support for dynamically allocated blobs.  If a host supports this feature, it
MUST pass an LV2_Feature with URI http://lv2plug.in/ns/dev/objects#blobSupport
and a pointer to LV2_Blob_Support as data to the plugin's instantiate method.
See object.h for details.
""" .


obj:BlobType a rdfs:Class ;
	rdfs:label      "Blob Type" ;
	rdfs:comment    """
Base class for all types of dynamically allocated LV2 blobs.  Blobs can be of
any type at all, there are no restrictions on the binary format or contents
of a blob.  Blobs are dynamically allocated by the host (or a plugin via
the host), and unlike Objects are not necessarily POD.

The type of a blob MAY be a obj:ObjectType, in which case the start of the
blob data is the start of the Object header (LV2_Object).
""" .

