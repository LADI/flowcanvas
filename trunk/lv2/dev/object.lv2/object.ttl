# LV2 Objects Extension
#
# Copyright (C) 2007 Dave Robillard
# 
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.

@prefix obj:  <http://lv2plug.in/ns/dev/objects#> .
@prefix lv2:  <http://lv2plug.in/ns/lv2core#> .
@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd:  <http://www.w3.org/2001/XMLSchema> .
@prefix doap: <http://usefulinc.com/ns/doap#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .

<http://lv2plug.in/ns/dev/objects>
	a lv2:Specification ;
    doap:name "LV2 Objects" ;
	rdfs:comment """
This extension defines a genic format for "objects" (e.g. integers,
strings, buffers, data structures, etc) to be used by LV2 plugins and hosts.
Objects may be contained directly in port buffers, or used in other ways,
e.g. as the payload of an event or as persistent data.  Objects are very
simple chunks of memory with a type and a size, and are (with one exception)
POD and may be safely copied (allowing plugins and hosts to communicate
objects of any type, even if they do not understand them).

Optionally, the host may support "Blobs", which are dynamically allocated
chunks of memory that (unlike "Objects") are not necessarily POD.  Blobs
are referred to by references, which are a special case of Object that
always have type 0, are not POD, and can only be copied using host provided
functions.  Blob support requires the host to support the
<a href="http://lv2plug.in/ns/ext/uri-map">LV2 URI Map</a> extension.
""" .


obj:ObjectPort a rdfs:Class ;
    rdfs:label      "Object port" ;
    rdfs:subClassOf lv2:Port ;
    rdfs:comment    """
Ports of this type will be connected to a struct of type LV2_Object (as
defined in object.h) aligned to 32-bits.  Before calling the run method
(or equivalent for the port's context) the host guarantees that:
<ul>
<li>All ObjectPort inputs are connected to a valid LV2_Object with type and
size set accordingly, or NULL if lv2:connectionOptional.</li>
<li>All ObjectPort outputs are connected to an LV2_Object with size set to
the number of bytes of space available immediately following the LV2_Object
header, or NULL if lv2:connectionOptional.  The type and contents MUST NOT
be interpreted by the plugin.</li>
</ul>
Before returning from the run method (or equivalent for the port's context),
the plugin guarantees that:
<ul>
<li>All connected ObjectPort outputs have type and size set appropriately.
If nothing was written to the output, the plugin MUST set both type and size
to 0.
</li>
</ul>
""" .


obj:ObjectType a rdfs:Class ;
	rdfs:label   "LV2 Object Type" ;
	rdfs:comment """
Base class for all types of LV2 Objects.

All Object types (instances of this class, which are themselves classes) must
define a precise binary layout for that type of object, which dictates the
format of the data following the LV2_Object header.  Pedantically, this class
refers to the type of memory starting where the LV2_Object header starts,
i.e. a chunk of memory with any type that is a subClassOf obj:ObjectType
by definition starts with an LV2_Object.

The URIs of subclasses of obj:ObjectType are mapped to integers and used as
the type field of an LV2_Object.  If a plugin or host does not understand
the type of an LV2_Object, that object SHOULD simply be ignored.

All objects are POD by definition, except references, which have type 0.
Specifically, it is safe to copy any type of object except type 0 with a
simple memcpy using the size field, even if the implementation does not
understand the actual type of that object.
""" .


obj:Reference a obj:ObjectType ;
	rdfs:label   "Reference" ;
	rdfs:comment """
Reference to a blob.  The actual contents of a reference are opaque and host
specific, and must not be copied, serialized, or otherwise interpreted by
a plugin.

References are a special case: a reference object always has type 0.
""" .


obj:String a obj:ObjectType ;
	rdfs:label "String" ;
	rdfs:comment """
A UTF-8 encoded string, where LV2_Object.size refers to the length of the
string in bytes (not characters).
""" .


obj:Tuple a obj:ObjectType ;
	rdfs:label "Tuple" ;
	rdfs:comment """
A POD heterogeneous sequence of Objects.  A Tuple can contain objects of
varying type and varying size.  The body of the tuple
is simply the body of the first element, followed by the body of the
second, etc., where each is aligned to 32-bits.
""" .

obj:Vector a obj:ObjectType ;
	rdfs:label "Vector" ;
	rdfs:comment """
A POD homogeneous sequence of fixed-size objects.  A Vector contains
some number of objects, all with the same type and size.
<pre>
struct {
	uint32_t type;
	uint32_t count;
}</pre>
followed by 'count' representations of objects of type 'type', which must be
a fixed size obj:ObjectType.  Vector is an efficient packed type; the contained
objects do NOT have LV2_Object headers.  Only objects with a fixed size type may
be stored in a Vector.  For example, an obj:Vector containing 42 elements of
type obj:Int32 looks like this in memory:
<pre>
struct {
	uint32_t object_type = uri_map(obj:Vector)
	uint32_t object_size = (2 * sizeof(uint32_t)) + (42 * sizeof(int32_t))
	uint32_t type        = uri_map(obj:Int32)
	uint32_t count       = 42

	int32_t contents[42];
}
</pre>
""" .

obj:Int32   a obj:ObjectType ; rdfs:label "Signed 32-bit Integer" .
obj:Float32 a obj:ObjectType ; rdfs:label "32-bit Floating Point Number" .


obj:blobSupport a lv2:Feature ;
	rdfs:label "Blob support" ;
	rdfs:comment """
Support for dynamically allocated blobs.  If a host supports this feature, it
MUST pass an LV2_Feature with URI http://lv2plug.in/ns/dev/objects#blobSupport
and a pointer to LV2_Blob_Support as data to the plugin's instantiate method.
See object.h for details.
""" .


obj:BlobType a rdfs:Class ;
	rdfs:label      "Blob Type" ;
	rdfs:comment    """
Base class for all types of dynamically allocated LV2 blobs.

A particular type must be either a obj:BlobType OR a obj:ObjectType, it
MUST NOT be both (since LV2_Object and LV2_Blob are not compatible).  A
blob may <em>contain</em> an LV2_Object, but is never itself one.

Blobs are dynamically allocated by the host (or a plugin via the host),
and unlike Objects are not necessarily POD.
""" .

