# LV2 Objects Extension
#
# Copyright (C) 2007 Dave Robillard
# 
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.

@prefix obj:  <http://lv2plug.in/ns/dev/objects#> .
@prefix lv2:  <http://lv2plug.in/ns/lv2core#> .
@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd:  <http://www.w3.org/2001/XMLSchema> .
@prefix doap: <http://usefulinc.com/ns/doap#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .

<http://lv2plug.in/ns/dev/objects>
	a lv2:Specification ;
    doap:name "LV2 Objects" ;
	rdfs:comment """
This extension defines a generic format for "objects" (e.g. integers,
strings, buffers, data structures, etc) to be used by LV2 plugins and hosts.
Objects may be contained directly in port buffers, or used in other ways,
e.g. as an event or as shared data.  Objects are very simple chunks of
memory with a type and a size, and are (with one exception) Plain Old Data
(POD) and may be safely copied.  Because they are POD, hosts and plugins can
communicate objects of any type, even if they do not understand that type.
This allows two plugins that both understand some type to be used together in
a host that does not itself understand that type, or allows a host to send
objects "through" a plugin that does not understand them (for e.g. routing,
delaying, or buffering plugins).

Objects as defined by this extension can be trivially constructed in-place
from events as defined by the <a href="http://lv2plug.in/ns/ext/event">LV2
Event</a> extension.  A valid LV2_Object (see object.h) is contained within
any valid LV2_Event (see event.h).  An LV2_Event is simply an LV2_Object
with a time stamp (relative to the current audio block).  Object ports
are particularly useful on contexts that run for a single instant in time,
e.g. a MessagePort (which is-a ObjectPort) can be considered the instantaneous
equivalent of an EventPort (which reflects a range of time).  The relationship
is similar to that of Control and Audio ports.

Optionally, the host MAY support "Blobs", which are dynamically allocated
chunks of memory that (unlike Objects) are not necessarily POD.  Blobs are
referred to by references, which are a special case of Object that always have
type 0, are not POD, and can only be copied using host provided functions.
This allows plugins and hosts to work with data of any type at all.
The address of a blob MUST NOT be used in any way by an implementation
that does not understand that blob type (meaningful type-oblivious use is
impossible, the address may not even point to RAM).

This extension requires the host to support the <a
href="http://lv2plug.in/ns/ext/uri-map">LV2 URI Map</a> extension.
""" .


obj:ObjectPort a rdfs:Class ;
    rdfs:label      "Object Port" ;
    rdfs:subClassOf lv2:Port ;
    rdfs:comment    """
Ports of this type will be connected to a region of 32-bit aligned memory
that starts with a uint32_t type, immediately followed by a uint32_t size,
immediately followed by that many bytes of data (see LV2_Object in object.h).

This is an abstract port type.  A port that is a obj:ObjectPort MUST also
have a more descriptive type that is a subClassOf obj:ObjectPort which
defines the port's semantics (probably obj:ValuePort or obj:MessagePort).

Before calling a method on the plugin that writes to an ObjectPort output,
the host MUST set the size of the Object in that output to the amount of
available memory immediately following the Object header.  The plugin MUST
write a valid Object that port (leaving it untouched is illegal).  If there
is no reasonable value to write to the port, the plugin MUST write null
(the object with both type and size equal to zero).
""" .


obj:asLargeAs a rdf:Property ;
    rdfs:domain  obj:ObjectPort ;
    rdfs:range   lv2:Symbol ;
    rdfs:label   "as large as" ;
    rdfs:comment """
Indicates that an object port requires at least as much buffer space as
the port with the given symbol on the same plugin instance.  If a port is
asLargeAs several ports, it is asLargeAs the largest such port (not the sum
of those ports' sizes).

The host guarantees that whenever an ObjectPort's run method is called,
any output O that is obj:asLargeAs an input I is connected to a buffer large
enough to copy I, or NULL if the port is lv2:connectionOptional.
""" .


obj:respondsWith a rdf:Property ;
    rdfs:domain  obj:MessagePort ;
    rdfs:range   lv2:Symbol ;
    rdfs:label   "responds with" ;
    rdfs:comment """
Indicates that a message port responds to messages via the port with the
given symbol on the same plugin instance.  If <pre>input obj:respondsWith
output</pre> then after running the plugin with a message <em>m</em> in
<code>input</code> the host SHOULD interpret the object in <code>output</code>
as the response to <em>m</em>.
""" .


obj:ValuePort a rdfs:Class ;
    rdfs:label      "Value Port" ;
    rdfs:subClassOf obj:ObjectPort ;
    rdfs:comment    """
The contents of a ValuePort are considered persistent and time-independent.
<ul>
<li>If a plugin has fixed input values for all ports, all ValuePort outputs
are also fixed regardless of the number of times the plugin is run.</li>
<li>If a plugin has fixed input values for all ports except a ValuePort,
each value V of that ValuePort corresponds to a single set of outputs
for all ports.</li>
<li>If an obj:ValuePort contains a reference then the blob it refers to is
constant; plugin MUST NOT modify the blob in any way.
</ul>

Intuitively, the contents of a ValuePort are values (which are computed),
NOT commands (which are executed, or otherwise consumed to manipulate state).
""" .


obj:MessagePort a rdfs:Class ;
    rdfs:label      "Message Port" ;
    rdfs:subClassOf obj:ObjectPort ;
    rdfs:comment    """
An ObjectPort that consumes or executes its value as a "message".  The contents
of a MessagePort are considered transient and/or time-dependent, and only
apply for a single invocation of its run method.  Unlike a ValuePort,
a MessagePort may be used to manipulate and access internal plugin state.

Intuitively, the contents of a MessagePort are commands (which are executed
or consumed once).

Plugins may respond to messages via another messagePort as specified by the
obj:respondsWith property.
""" .


obj:ObjectType a rdfs:Class ;
	rdfs:label   "LV2 Object Type" ;
	rdfs:comment """
Base class for all types of LV2 Objects.

All Object types (instances of this class, which are themselves classes)
must define a precise binary layout for that type of object, which dictates
the format of the data following the LV2_Object header.  Pedantically, this
class refers to the type of memory starting where the LV2_Object header starts,
i.e. a chunk of memory with any type that is a subClassOf obj:ObjectType by
definition starts with an LV2_Object.  The area after the header is referred
to as the object's "body".

The URIs of subclasses of obj:ObjectType are mapped to integers and used as
the type field of an LV2_Object.  If a plugin or host does not understand
the type of an LV2_Object, that object SHOULD simply be ignored.

All objects are POD by definition, except references, which have type 0.
An object MUST NOT contain a reference.  It is safe to copy any type of
object except type 0 with a simple memcpy using the size field, even if the
implementation does not understand the actual type of that object.
""" .


obj:Reference a obj:ObjectType ;
	rdfs:label   "Reference" ;
	rdfs:comment """
Reference to a blob.  The actual contents of a reference are opaque and host
specific, and must not be copied, serialized, or otherwise interpreted by
a plugin, except by using functions provided by the host.

References are a special case: a reference object always has type 0.
The NULL reference is the unique object with type 0 and size 0.
""" .


obj:String a obj:ObjectType ;
	rdfs:label "String" ;
	rdfs:comment """
A UTF-8 encoded string, where LV2_Object.size refers to the length of the
string in bytes (not characters).
""" .


obj:Vector a obj:ObjectType ;
	rdfs:label "Vector" ;
	rdfs:comment """
A POD homogeneous sequence of objects with equivalent type and size.

The body of a vector begins with
<pre>
uint16_t elem_count; // The number of elements in the vector
uint16_t elem_type;  // The type of each element
</pre>
followed by <code>elem_count</code> bodies of objects of type
<code>elem_type</code>, each with equivalent size.  For variably sized
content types, this size can be calculated using the total byte size of the
vector, e.g.
<pre>
uint16_t elem_size = (vector.size - (2 * sizeof(uint16_t))) / vector.count);
</pre>
Note that it is possible to construct a valid Object for each element of the
vector, even by an implementation which does not understand <code>type</code>.

For example, an obj:Vector containing 42 elements of type obj:Int32 looks
like this in memory:
<pre>
uint16_t object_type  = uri_map(obj:Vector)
uint16_t object_size  = (2 * sizeof(uint16_t)) + (42 * sizeof(int32_t))
uint16_t elem_count   = 42
uint16_t elem_type    = uri_map(obj:Int32)
int32_t  contents[42] = ...
</pre>
""" .

obj:Bang    a obj:ObjectType ; rdfs:label "Bang (generic activity), size=0" .
obj:Byte    a obj:ObjectType ; rdfs:label "A byte" .
obj:Int32   a obj:ObjectType ; rdfs:label "Signed 32-bit Integer" .
obj:Bool    a obj:ObjectType ; rdfs:label "obj:Int32 where 0=false, 1=true" .
obj:Float32 a obj:ObjectType ; rdfs:label "32-bit Floating Point Number" .
obj:Float64 a obj:ObjectType ; rdfs:label "64-bit Floating Point Number" .


obj:blobSupport a lv2:Feature ;
	rdfs:label "Blob support" ;
	rdfs:comment """
Support for dynamically allocated blobs.  If a host supports this feature, it
MUST pass an LV2_Feature with URI http://lv2plug.in/ns/dev/objects#blobSupport
and a pointer to LV2_Blob_Support as data to the plugin's instantiate method.
See object.h for details.
""" .


obj:BlobType a rdfs:Class ;
	rdfs:label      "Blob Type" ;
	rdfs:comment    """
Base class for all types of dynamically allocated LV2 blobs.  Blobs can be of
any type at all, there are no restrictions on the binary format or contents
of a blob.  Blobs are dynamically allocated by the host (or a plugin via
the host), and unlike Objects are not necessarily POD.

The type of a blob MAY be a obj:ObjectType, in which case the start of the
blob data is the start of the Object header (LV2_Object).
""" .

